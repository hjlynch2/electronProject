'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.format_livethread_permissions = exports.format_mod_permissions = undefined;

var _remove2 = require('lodash/remove');

var _remove3 = _interopRequireDefault(_remove2);

var _property2 = require('lodash/property');

var _property3 = _interopRequireDefault(_property2);

var _partial2 = require('lodash/partial');

var _partial3 = _interopRequireDefault(_partial2);

var _omit2 = require('lodash/omit');

var _omit3 = _interopRequireDefault(_omit2);

var _keyBy2 = require('lodash/keyBy');

var _keyBy3 = _interopRequireDefault(_keyBy2);

var _isEmpty2 = require('lodash/isEmpty');

var _isEmpty3 = _interopRequireDefault(_isEmpty2);

var _includes2 = require('lodash/includes');

var _includes3 = _interopRequireDefault(_includes2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _find2 = require('lodash/find');

var _find3 = _interopRequireDefault(_find2);

var _filter2 = require('lodash/filter');

var _filter3 = _interopRequireDefault(_filter2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.get_empty_replies_listing = get_empty_replies_listing;
exports.add_empty_replies_listing = add_empty_replies_listing;
exports.handle_json_errors = handle_json_errors;
exports.find_message_in_tree = find_message_in_tree;
exports.format_permissions = format_permissions;
exports.rename_key = rename_key;
exports.build_replies_tree = build_replies_tree;
exports.add_fullname_prefix = add_fullname_prefix;
exports.has_fullname_prefix = has_fullname_prefix;

var _constants = require('./constants.js');

var _More = require('./objects/More.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function get_empty_replies_listing(item) {
  if (item.constructor.name === 'Comment') {
    return item._r._new_object('Listing', {
      _uri: 'comments/' + item.link_id.slice(3),
      _query: { comment: item.name.slice(3) },
      _transform: (0, _property3.default)('comments[0].replies'),
      _link_id: item.link_id,
      _is_comment_list: true
    });
  }
  if (item.constructor.name === 'Submission') {
    return item._r._new_object('Listing', {
      _uri: 'comments/' + item.id,
      _transform: (0, _property3.default)('comments'),
      _is_comment_list: true
    });
  }
  return item._r._new_object('Listing');
}

function add_empty_replies_listing(item) {
  item.replies = get_empty_replies_listing(item);
  return item;
}

function handle_json_errors(returnValue) {
  return response => {
    if ((0, _isEmpty3.default)(response) || (0, _isEmpty3.default)(response.json.errors)) {
      return returnValue;
    }
    throw new Error(response.json.errors[0]);
  };
}

// Performs a depth-first search of a tree of private messages, in order to find a message with a given name.
function find_message_in_tree(desired_name, root_node) {
  return root_node.name === desired_name ? root_node : (0, _find3.default)(root_node.replies.map((0, _partial3.default)(find_message_in_tree, desired_name)));
}

function format_permissions(all_permission_names, perms_array) {
  return perms_array ? all_permission_names.map(type => ((0, _includes3.default)(perms_array, type) ? '+' : '-') + type).join(',') : '+all';
}

const format_mod_permissions = exports.format_mod_permissions = (0, _partial3.default)(format_permissions, _constants.MODERATOR_PERMISSIONS);
const format_livethread_permissions = exports.format_livethread_permissions = (0, _partial3.default)(format_permissions, _constants.LIVETHREAD_PERMISSIONS);

function rename_key(obj, old_key, new_key) {
  return obj && (0, _omit3.default)(_extends({}, obj, { [new_key]: obj[old_key] }), old_key);
}

/* When reddit returns private messages (or comments from the /api/morechildren endpoint), it arranges their in a very
nonintuitive way (see https://github.com/not-an-aardvark/snoowrap/issues/15 for details). This function rearranges the message
tree so that replies are threaded properly. */
function build_replies_tree(child_list) {
  const child_map = (0, _keyBy3.default)(child_list, 'name');
  (0, _forEach3.default)(child_list, add_empty_replies_listing);
  (0, _forEach3.default)((0, _filter3.default)(child_list, child => child.constructor.name === 'Comment'), child => {
    child.replies._more = _More.empty_children;
  });
  (0, _remove3.default)(child_list, child => child_map[child.parent_id]).forEach(child => {
    if (child.constructor.name === 'More') {
      child_map[child.parent_id].replies._set_more(child);
      child.link_id = child_map[child.parent_id].link_id;
    } else {
      child_map[child.parent_id].replies.push(child);
    }
  });
  return child_list;
}

function add_fullname_prefix(item, prefix) {
  if (typeof item === 'string') {
    return has_fullname_prefix(item) ? item : prefix + item;
  }
  return item.name;
}

function has_fullname_prefix(item) {
  return (/^(t\d|LiveUpdateEvent)_/.test(item)
  );
}