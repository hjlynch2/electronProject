'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _mapValues2 = require('lodash/mapValues');

var _mapValues3 = _interopRequireDefault(_mapValues2);

var _keys2 = require('lodash/keys');

var _keys3 = _interopRequireDefault(_keys2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _promiseChains = require('promise-chains');

var _promiseChains2 = _interopRequireDefault(_promiseChains);

var _util = require('util');

var _constants = require('../constants.js');

var _Listing = require('./Listing.js');

var _Listing2 = _interopRequireDefault(_Listing);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* A base class for content from reddit. With the expection of Listings, all content types extend this class.
* This class should be considered 'abstract', to the extend that JavaScript classes can be -- it should not be necessary to
* instantiate it directly.
* <style> #RedditContent {display: none} </style>
*/
const RedditContent = class {
  constructor(options, _r, _has_fetched) {
    // _r refers to the snoowrap requester that is used to fetch this content.
    this._r = _r;
    this._fetch = null;
    this._has_fetched = !!_has_fetched;
    (0, _assign3.default)(this, options);
    if (typeof Proxy !== 'undefined' && !this._has_fetched) {
      return new Proxy(this, { get(target, key) {
          return key in target || key === 'length' || key in _bluebird2.default.prototype ? target[key] : target.fetch()[key];
        } });
    }
  }
  /**
  * @summary Fetches this content from reddit.
  * @desc This will not mutate the original content object; all Promise properties will remain as Promises after the content has
  * been fetched. However, the information on this object will be cached, so it may become out-of-date with the content on
  * reddit. To clear the cache and fetch this object from reddit again, use `refresh()`.
  *
  * If snoowrap is running in an environment that supports ES2015 Proxies (e.g. Chrome 49+), then `fetch()` will get
  * automatically called when an unknown property is accessed on an unfetched content object.
  * @returns {Promise} A version of this object with all of its fetched properties from reddit. This will not mutate the
  object. Once an object has been fetched once, its properties will be cached, so they might end up out-of-date if this
  function is called again. To refresh an object, use refresh().
  * @example
  *
  * r.get_user('not_an_aardvark').fetch().then(user_info => {
  *   console.log(user_info.name); // 'not_an_aardvark'
  *   console.log(user_info.created_utc); // 1419104352
  * });
  *
  * r.get_comment('d1xchqn').fetch().then(comment => comment.body).then(console.log)
  * // => 'This is a little too interesting for my liking'
  *
  * // In environments that support ES2015 Proxies, the above line is equivalent to:
  * r.get_comment('d1xchqn').body.then(console.log);
  * // => 'This is a little too interesting for my liking'
  */
  fetch() {
    if (!this._fetch) {
      this._fetch = (0, _promiseChains2.default)(this._r._get({ uri: this._uri }).bind(this).then(this._transform_api_response));
    }
    return this._fetch;
  }
  /**
  * @summary Refreshes this content.
  * @returns {Promise} A newly-fetched version of this content
  * @example
  *
  * var some_comment = r.get_comment('cmfkyus');
  * var initial_comment_body = some_comment.fetch().then(comment => comment.body);
  *
  * setTimeout(() => {
  *   some_comment.refresh().then(refreshed_comment => {
  *     if (initial_comment_body.value() !== refreshed_comment.body) {
  *       console.log('This comment has changed since 10 seconds ago.');
  *     }
  *   });
  * }, 10000);
  */
  refresh() {
    this._fetch = null;
    return this.fetch();
  }
  /**
  * @summary Returns a stringifyable version of this object.
  * @desc It is usually not necessary to call this method directly; simply running JSON.stringify(some_object) will strip the
  private properties anyway.
  * @returns {object} A version of this object with all the private properties stripped
  * @example
  *
  * var user = r.get_user('not_an_aardvark');
  * JSON.stringify(user) // => '{"name":"not_an_aardvark"}'
  */
  toJSON() {
    return (0, _mapValues3.default)(this._strip_private_props(), (value, key) => {
      if (value instanceof RedditContent && !value._has_fetched) {
        if (value.constructor.name === 'RedditUser' && _constants.USER_KEYS.has(key)) {
          return value.name;
        }
        if (value.constructor.name === 'Subreddit' && _constants.SUBREDDIT_KEYS.has(key)) {
          return value.display_name;
        }
      }
      return value && value.toJSON ? value.toJSON() : value;
    });
  }
  inspect() {
    return this.constructor.name + ' ' + (0, _util.inspect)(this._strip_private_props());
  }
  _strip_private_props() {
    return (0, _pick3.default)(this, (0, _keys3.default)(this).filter(key => !key.startsWith('_')));
  }
  _transform_api_response(response_object) {
    return response_object;
  }
  _clone() {
    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var _ref$deep = _ref.deep;
    let deep = _ref$deep === undefined ? false : _ref$deep;

    const cloned_props = (0, _mapValues3.default)(this, value => {
      if (deep) {
        return value instanceof RedditContent || value instanceof _Listing2.default ? value._clone({ deep }) : (0, _cloneDeep3.default)(value);
      }
      return value;
    });
    return this._r._new_object(this.constructor.name, cloned_props, this._has_fetched);
  }
  _get_listing() {
    var _r2;

    return (_r2 = this._r)._get_listing.apply(_r2, arguments);
  }
};

(0, _forEach3.default)(_constants.HTTP_VERBS, method => {
  Object.defineProperty(RedditContent.prototype, '_' + method, { value() {
      var _r3;

      return (_r3 = this._r)['_' + method].apply(_r3, arguments);
    } });
});

exports.default = RedditContent;