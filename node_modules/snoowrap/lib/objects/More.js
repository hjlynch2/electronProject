'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.empty_children = undefined;

var _remove2 = require('lodash/remove');

var _remove3 = _interopRequireDefault(_remove2);

var _pick2 = require('lodash/pick');

var _pick3 = _interopRequireDefault(_pick2);

var _forEach2 = require('lodash/forEach');

var _forEach3 = _interopRequireDefault(_forEach2);

var _flatten2 = require('lodash/flatten');

var _flatten3 = _interopRequireDefault(_flatten2);

var _concat2 = require('lodash/concat');

var _concat3 = _interopRequireDefault(_concat2);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _assign2 = require('lodash/assign');

var _assign3 = _interopRequireDefault(_assign2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _helpers = require('../helpers.js');

var _constants = require('../constants.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const api_type = 'json';

/**
* The `More` class is a helper representing reddit's exposed `more` type in comment threads, used to fetch additional comments
on a thread.
* No instances of the `More` class are exposed externally by snoowrap; instead, comment lists are exposed as Listings.
Additional replies on an item can be fetched by calling `fetch_more` on a Listing, in the same manner as what would be done
with a Listing of posts. snoowrap should handle the differences internally, and expose a nearly-identical interface for the
two use-cases.

Combining reddit's `Listing` and `more` objects has the advantage of having a more consistent exposed interface; for example,
if a consumer iterates over the comments on a Submission, all of the iterated items will actually be Comment objects, so the
consumer won't encounter an unexpected `more` object at the end. However, there are a few disadvantages, namely that (a) this
leads to an increase in internal complexity, and (b) there are a few cases where reddit's `more` objects have different amounts
of available information (e.g. all the child IDs of a `more` object are known on creation), which leads to different optimal
behavior.
*/

const More = class {
  constructor(options, _r) {
    (0, _assign3.default)(this, options);
    this._r = _r;
  }
  /* Requests to /api/morechildren are capped at 20 comments at a time, but requests to /api/info are capped at 100, so
  it's easier to send to the latter. The disadvantage is that comment replies are not automatically sent from requests
  to /api/info. */
  fetch_more(options) {
    let start_index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

    if (options.amount <= 0 || start_index >= this.children.length) {
      return _bluebird2.default.resolve([]);
    }
    if (!options.skip_replies) {
      return this.fetch_tree(options, start_index);
    }
    const ids = get_next_id_slice(this.children, start_index, options.amount, _constants.MAX_API_INFO_AMOUNT).map(id => 't1_' + id);
    // Requests are capped at 100 comments. Send lots of requests recursively to get the comments, then concatenate them.
    // (This speed-requesting is only possible with comment Listings since the entire list of ids is present initially.)
    const promise_for_this_batch = this._r._get_listing({ uri: 'api/info', qs: { id: ids.join(',') } });
    const next_request_options = _extends({}, options, { amount: options.amount - ids.length });
    const promise_for_remaining_items = this.fetch_more(next_request_options, start_index + ids.length);
    return _bluebird2.default.all([promise_for_this_batch, promise_for_remaining_items]).then(_flatten3.default);
  }
  fetch_tree(options, start_index) {
    if (options.amount <= 0 || start_index >= this.children.length) {
      return _bluebird2.default.resolve([]);
    }
    const ids = get_next_id_slice(this.children, start_index, options.amount, _constants.MAX_API_MORECHILDREN_AMOUNT);
    return this._r._get({
      uri: 'api/morechildren',
      qs: { api_type, children: ids.join(','), link_id: this.link_id || this.parent_id }
    }).tap(_helpers.handle_json_errors).then(res => res.json.data.things).mapSeries(_helpers.add_empty_replies_listing).then(_helpers.build_replies_tree).then(result_trees => {
      /* Sometimes, when sending a request to reddit to get multiple comments from a `more` object, reddit decides to only
      send some of the requested comments, and then stub out the remaining ones in a smaller `more` object. ( ¯\_(ツ)_/¯ )
      In these cases, recursively fetch the smaller `more` objects as well. */
      const child_mores = (0, _remove3.default)(result_trees, c => c instanceof More);
      (0, _forEach3.default)(child_mores, c => {
        c.link_id = this.link_id || this.parent_id;
      });
      return (0, _bluebird.mapSeries)(child_mores, c => c.fetch_tree(_extends({}, options, { amount: Infinity }), 0)).then(_flatten3.default).then(expanded => {
        return this.fetch_more(_extends({}, options, { amount: options.amount - ids.length }), start_index + ids.length).then(nexts => {
          return (0, _concat3.default)(result_trees, expanded, nexts);
        });
      });
    });
  }
  _clone() {
    return new More((0, _clone3.default)((0, _pick3.default)(this, Object.getOwnPropertyNames(this))), this._r);
  }
};

function get_next_id_slice(children, start_index, desired_amount, limit) {
  return children.slice(start_index, start_index + Math.min(desired_amount, limit));
}

const empty_children = exports.empty_children = new More({ children: [] });
exports.default = More;